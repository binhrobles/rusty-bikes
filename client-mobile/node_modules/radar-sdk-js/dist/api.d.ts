import * as errors from './errors';
import type { RadarError } from './errors';
import type { RadarPlugin } from './plugin';
import type { Location, NavigatorPosition, RadarAutocompleteParams, RadarAutocompleteResponse, RadarContextResponse, RadarConversionParams, RadarConversionResponse, RadarDistanceParams, RadarForwardGeocodeParams, RadarGeocodeResponse, RadarIPGeocodeResponse, RadarMatrixParams, RadarMatrixResponse, RadarMetadata, RadarOptions, RadarReverseGeocodeParams, RadarRouteResponse, RadarSearchGeofencesParams, RadarSearchGeofencesResponse, RadarSearchPlacesParams, RadarSearchPlacesResponse, RadarTrackParams, RadarTrackResponse, RadarTripOptions, RadarTripResponse, RadarValidateAddressParams, RadarValidateAddressResponse } from './types';
/**
 * main entry point for the Radar SDK. all methods are static â€” do not instantiate.
 *
 * @example
 * ```ts
 * Radar.initialize('prj_test_pk_...');
 * const { user, events } = await Radar.trackOnce();
 * ```
 */
declare class Radar {
    private static _plugins;
    static errors: typeof errors;
    /** current SDK version string */
    static get VERSION(): string;
    /** register one or more plugins (e.g. maps, autocomplete, fraud) */
    static registerPlugin(...plugins: RadarPlugin[]): void;
    private static _getPluginContext;
    /**
     * initialize the SDK with a publishable key. must be called before any other method.
     * @param publishableKey - your Radar publishable key (starts with `prj_test_pk_` or `prj_live_pk_`)
     * @param options - optional SDK configuration
     * @throws {RadarPublishableKeyError} if the key is missing or is a secret key
     */
    static initialize(publishableKey: string, options?: RadarOptions): void;
    /** clear all SDK state and configuration */
    static clear(): void;
    /** set the user ID for tracking. pass `undefined` to clear. */
    static setUserId(userId?: string): void;
    /** set a description for the current user. pass `undefined` to clear. */
    static setDescription(description?: string): void;
    /** set custom metadata for the current user. pass `undefined` to clear. */
    static setMetadata(metadata?: RadarMetadata): void;
    /** get the device's current location using the browser geolocation API */
    static getLocation(): Promise<NavigatorPosition>;
    /** track the user's current location once, returning location context and events */
    static trackOnce(params?: RadarTrackParams): Promise<RadarTrackResponse>;
    /** get context (geofences, place, regions) for a location without tracking */
    static getContext(params: Location): Promise<RadarContextResponse>;
    /** save trip options for tracking. pass `undefined` to clear */
    static setTripOptions(tripOptions?: RadarTripOptions): void;
    /** clear saved trip options */
    static clearTripOptions(): void;
    /** get the currently saved trip options */
    static getTripOptions(): RadarTripOptions;
    /** start a new trip with the given options */
    static startTrip(tripOptions: RadarTripOptions): Promise<RadarTripResponse>;
    /** update an in-progress trip */
    static updateTrip(tripOptions: RadarTripOptions): Promise<RadarTripResponse>;
    /** complete the current trip and clear local trip options */
    static completeTrip(): Promise<RadarTripResponse>;
    /** cancel the current trip and clear local trip options */
    static cancelTrip(): Promise<RadarTripResponse>;
    /** log a conversion event */
    static logConversion(params: RadarConversionParams): Promise<RadarConversionResponse>;
    /** set the product identifier for tracking requests. pass `undefined` to clear */
    static setProduct(product?: string): void;
    /** register a global error callback invoked on SDK errors */
    static onError(callback: (error: RadarError) => void): void;
    /** geocode an address or place name to coordinates */
    static forwardGeocode(params: RadarForwardGeocodeParams): Promise<RadarGeocodeResponse>;
    /** reverse geocode coordinates to addresses */
    static reverseGeocode(params: RadarReverseGeocodeParams): Promise<RadarGeocodeResponse>;
    /** geocode the device's IP address to a rough location */
    static ipGeocode(): Promise<RadarIPGeocodeResponse>;
    /** autocomplete partial addresses and place names */
    static autocomplete(params: RadarAutocompleteParams, requestId?: string): Promise<RadarAutocompleteResponse>;
    /** search for geofences near a location */
    static searchGeofences(params: RadarSearchGeofencesParams): Promise<RadarSearchGeofencesResponse>;
    /** search for places (POIs) near a location */
    static searchPlaces(params: RadarSearchPlacesParams): Promise<RadarSearchPlacesResponse>;
    /** validate a structured address */
    static validateAddress(params: RadarValidateAddressParams): Promise<RadarValidateAddressResponse>;
    /** calculate travel distance and duration between two points */
    static distance(params: RadarDistanceParams): Promise<RadarRouteResponse>;
    /** calculate a distance matrix between multiple origins and destinations */
    static matrix(params: RadarMatrixParams): Promise<RadarMatrixResponse>;
}
export default Radar;
