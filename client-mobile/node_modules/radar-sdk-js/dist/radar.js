/** global SDK configuration singleton */
class Config {
    /** store SDK options (called by Radar.initialize) */
    static setup(options = {}) {
        Config.options = options;
    }
    /** get the current SDK options */
    static get() {
        return Config.options || {};
    }
    /** clear all SDK options and error callback */
    static clear() {
        Config.options = {};
        Config.errorCallback = null;
    }
    /** register a callback invoked on SDK errors */
    static onError(callback) {
        Config.errorCallback = callback;
    }
    /** dispatch an error to the registered callback */
    static sendError(error) {
        if (Config.errorCallback && error) {
            Config.errorCallback(error);
        }
    }
}
/** registered error callback, if any */
Config.errorCallback = null;
/** default option values applied during initialization */
Config.defaultOptions = {
    live: false,
    logLevel: 'error',
    host: 'https://api.radar.io',
    version: 'v1',
    debug: false,
};

/** base error class for all Radar SDK errors */
class RadarError extends Error {
    constructor(message) {
        super(message);
    }
}
/** thrown when a publishable key is missing or invalid (e.g. secret key used) */
class RadarPublishableKeyError extends RadarError {
    constructor(message) {
        super(message);
        this.name = 'RadarPublishableKeyError';
        this.status = 'ERROR_PUBLISHABLE_KEY';
    }
}
/** thrown when the device location cannot be determined */
class RadarLocationError extends RadarError {
    constructor(message) {
        super(message);
        this.name = 'RadarLocationError';
        this.status = 'ERROR_LOCATION';
    }
}
/** thrown when location permissions are denied by the browser */
class RadarPermissionsError extends RadarError {
    constructor(message) {
        super(message);
        this.name = 'RadarPermissionsError';
        this.status = 'ERROR_PERMISSIONS';
    }
}
/** thrown on HTTP 400 Bad Request responses */
class RadarBadRequestError extends RadarError {
    constructor(response) {
        super(response?.meta?.message || 'Bad request.');
        this.name = 'RadarBadRequestError';
        this.status = 'ERROR_BAD_REQUEST';
        this.code = 400;
        this.response = response;
    }
}
/** thrown on HTTP 401 Unauthorized responses */
class RadarUnauthorizedError extends RadarError {
    constructor(response) {
        super(response?.meta?.message || 'Unauthorized.');
        this.name = 'RadarUnauthorizedError';
        this.status = 'ERROR_UNAUTHORIZED';
        this.code = 401;
        this.response = response;
    }
}
/** thrown on HTTP 402 Payment Required responses */
class RadarPaymentRequiredError extends RadarError {
    constructor(response) {
        super(response?.meta?.message || 'Payment required.');
        this.name = 'RadarPaymentRequiredError';
        this.status = 'ERROR_PAYMENT_REQUIRED';
        this.code = 402;
        this.response = response;
    }
}
/** thrown on HTTP 403 Forbidden responses */
class RadarForbiddenError extends RadarError {
    constructor(response) {
        super(response?.meta?.message || 'Forbidden.');
        this.name = 'RadarForbiddenError';
        this.status = 'ERROR_FORBIDDEN';
        this.code = 403;
        this.response = response;
    }
}
/** thrown on HTTP 404 Not Found responses */
class RadarNotFoundError extends RadarError {
    constructor(response) {
        super(response?.meta?.message || 'Not found.');
        this.name = 'RadarNotFoundError';
        this.status = 'ERROR_NOT_FOUND';
        this.code = 404;
        this.response = response;
    }
}
/** thrown on HTTP 429 Rate Limit responses */
class RadarRateLimitError extends RadarError {
    constructor(response) {
        super(response?.meta?.message || 'Rate limit exceeded.');
        this.name = 'RadarRateLimitError';
        this.status = 'ERROR_RATE_LIMIT';
        this.code = 429;
        this.response = response;
        this.type = response?.meta?.type;
    }
}
/** thrown on HTTP 5xx server errors */
class RadarServerError extends RadarError {
    constructor(response) {
        super(response?.meta?.message || 'Internal server error.');
        this.name = 'RadarServerError';
        this.status = 'ERROR_SERVER';
        this.response = response;
    }
}
/** thrown when a request times out or the network is unavailable */
class RadarNetworkError extends RadarError {
    constructor() {
        super('Request timed out.');
        this.name = 'RadarNetworkError';
        this.status = 'ERROR_NETWORK';
    }
}
/** thrown for unexpected/unclassified errors */
class RadarUnknownError extends RadarError {
    constructor(response) {
        super(response?.meta?.message || 'Something went wrong.');
        this.name = 'RadarUnknownError';
        this.status = 'ERROR_UNKNOWN';
        this.response = response;
    }
}

var errors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    RadarBadRequestError: RadarBadRequestError,
    RadarError: RadarError,
    RadarForbiddenError: RadarForbiddenError,
    RadarLocationError: RadarLocationError,
    RadarNetworkError: RadarNetworkError,
    RadarNotFoundError: RadarNotFoundError,
    RadarPaymentRequiredError: RadarPaymentRequiredError,
    RadarPermissionsError: RadarPermissionsError,
    RadarPublishableKeyError: RadarPublishableKeyError,
    RadarRateLimitError: RadarRateLimitError,
    RadarServerError: RadarServerError,
    RadarUnauthorizedError: RadarUnauthorizedError,
    RadarUnknownError: RadarUnknownError
});

const LOG_LEVELS = {
    none: 0,
    error: 1,
    warn: 2,
    info: 3,
    debug: 4,
};
// get the numeric level for logLevel option
const getLevel = () => {
    // disable logging in tests
    if (window && window.RADAR_TEST_ENV) {
        return LOG_LEVELS.none;
    }
    const { logLevel, debug } = Config.get();
    if (debug) {
        return LOG_LEVELS.debug;
    }
    if (logLevel) {
        return LOG_LEVELS[logLevel];
    }
    return LOG_LEVELS.error; // default to error-level logging if not set
};
/** leveled console logger controlled by SDK config */
class Logger {
    /** log a debug-level message (only when debug mode is enabled) */
    static debug(message, options) {
        if (getLevel() === LOG_LEVELS.debug) {
            console.log(`Radar SDK (debug): ${message.trim()}`, options);
        }
    }
    /** log an info-level message */
    static info(message) {
        if (getLevel() >= LOG_LEVELS.info) {
            console.log(`Radar SDK: ${message.trim()}`);
        }
    }
    /** log a warning-level message */
    static warn(message) {
        if (getLevel() >= LOG_LEVELS.warn) {
            console.warn(`Radar SDK: ${message.trim()}`);
        }
    }
    /** log an error-level message */
    static error(message) {
        if (getLevel() >= LOG_LEVELS.error) {
            console.error(`Radar SDK: ${message.trim()}`);
        }
    }
}

/** typed localStorage wrapper with `radar-*` namespaced keys */
class Storage {
    /** localStorage key for user ID */
    static get USER_ID() {
        return 'radar-userId';
    }
    /** localStorage key for device ID */
    static get DEVICE_ID() {
        return 'radar-deviceId';
    }
    /** localStorage key for install ID */
    static get INSTALL_ID() {
        return 'radar-installId';
    }
    /** localStorage key for session ID */
    static get SESSION_ID() {
        return 'radar-sessionId';
    }
    /** localStorage key for user description */
    static get DESCRIPTION() {
        return 'radar-description';
    }
    /** localStorage key for user metadata */
    static get METADATA() {
        return 'radar-metadata';
    }
    /** localStorage key for cached location */
    static get CACHED_LOCATION() {
        return 'radar-cached-location';
    }
    /** localStorage key for trip options */
    static get TRIP_OPTIONS() {
        return 'radar-trip-options';
    }
    /** localStorage key for product identifier */
    static get PRODUCT() {
        return 'radar-product';
    }
    /** @internal get the underlying localStorage instance */
    static getStorage() {
        const storage = window?.localStorage;
        if (!storage) {
            Logger.warn('localStorage not available.');
        }
        return storage;
    }
    /**
     * store a string value in localStorage
     * @param key - the storage key
     * @param value - the string value to store
     */
    static setItem(key, value) {
        const storage = this.getStorage();
        if (!storage) {
            return;
        }
        if (value === undefined || value === null) {
            return;
        }
        storage.setItem(key, value);
    }
    /**
     * retrieve a string value from localStorage
     * @param key - the storage key
     * @returns the stored value, or null if not found
     */
    static getItem(key) {
        const storage = this.getStorage();
        if (!storage) {
            return null;
        }
        const value = storage.getItem(key);
        if (value !== undefined && value !== null) {
            return value;
        }
        return null;
    }
    /**
     * retrieve and parse a JSON value from localStorage
     * @param key - the storage key
     * @returns the parsed object, or null if not found or parse fails
     */
    static getJSON(key) {
        const item = this.getItem(key);
        if (!item) {
            return null;
        }
        try {
            return JSON.parse(item);
        }
        catch {
            Logger.warn(`could not getJSON from storage for key: ${key}`);
            return null;
        }
    }
    /**
     * remove an item from localStorage
     * @param key - the storage key to remove
     */
    static removeItem(key) {
        const storage = this.getStorage();
        if (!storage) {
            return null;
        }
        storage.removeItem(key);
    }
    /** clear all localStorage entries */
    static clear() {
        const storage = this.getStorage();
        if (!storage) {
            return null;
        }
        storage.clear();
    }
}

const DEFAULT_POSITION_OPTIONS = {
    maximumAge: 0,
    timeout: 1000 * 10, // 10 seconds
    enableHighAccuracy: true,
};
// set "enableHighAccuracy" for navigator only when desiredAccuracy is "high"
const useHighAccuracy = (desiredAccuracy) => Boolean(desiredAccuracy === 'high');
/** browser geolocation wrapper with caching and permission checks */
class Navigator {
    /**
     * get the device's current position via the browser geolocation API
     * @param overrides - optional accuracy overrides
     * @returns device coordinates with accuracy
     * @throws {RadarLocationError} if geolocation is unavailable or times out
     * @throws {RadarPermissionsError} if location permissions are denied
     */
    static async getCurrentPosition(overrides = {}) {
        return new Promise((resolve, reject) => {
            const options = Config.get();
            if (!navigator || !navigator.geolocation) {
                return reject(new RadarLocationError('navigator.geolocation is not available.'));
            }
            // use cached location if available and options are set
            if (options.cacheLocationMinutes) {
                try {
                    const rawCachedLocation = Storage.getItem(Storage.CACHED_LOCATION);
                    if (rawCachedLocation) {
                        const cachedLocation = JSON.parse(rawCachedLocation);
                        const { latitude, longitude, accuracy, expiresAt } = cachedLocation || {};
                        if (Date.now() < parseInt(expiresAt)) {
                            if (latitude && longitude && accuracy) {
                                return resolve({ latitude, longitude, accuracy });
                            }
                        }
                    }
                }
                catch {
                    Logger.warn('could not load cached location.');
                }
            }
            // set options from config
            const positionOptions = Object.assign({}, DEFAULT_POSITION_OPTIONS);
            if (options.locationMaximumAge !== undefined) {
                positionOptions.maximumAge = options.locationMaximumAge;
            }
            if (options.locationTimeout !== undefined) {
                positionOptions.timeout = options.locationTimeout;
            }
            if (options.desiredAccuracy !== undefined) {
                positionOptions.enableHighAccuracy = useHighAccuracy(options.desiredAccuracy);
            }
            // set options from overrides
            if (overrides.desiredAccuracy !== undefined) {
                positionOptions.enableHighAccuracy = useHighAccuracy(overrides.desiredAccuracy);
            }
            Logger.info(`Using geolocation options: ${JSON.stringify(positionOptions)}`);
            // get current location from browser
            navigator.geolocation.getCurrentPosition((position) => {
                if (!position || !position.coords) {
                    return reject(new RadarLocationError('device location return empty coordinates.'));
                }
                const { latitude, longitude, accuracy } = position.coords;
                // cache location if option is set
                if (options.cacheLocationMinutes) {
                    const cacheLocationMinutes = Number.parseFloat(options.cacheLocationMinutes);
                    const updatedAt = Date.now();
                    const expiresAt = updatedAt + cacheLocationMinutes * 60 * 1000; // convert to ms
                    const lastLocation = { latitude, longitude, accuracy, updatedAt, expiresAt };
                    Storage.setItem(Storage.CACHED_LOCATION, JSON.stringify(lastLocation));
                }
                return resolve({ latitude, longitude, accuracy });
            }, (err) => {
                // location call failed or user did not grant permission
                if (err && err.code === 1) {
                    // https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPositionError
                    // code 1 means location permissions denied
                    // codes 2 and 3 mean location unavailable or timeout
                    return reject(new RadarPermissionsError('Location permissions denied.'));
                }
                return reject(new RadarLocationError('Could not determine location.'));
            }, positionOptions);
        });
    }
    /**
     * query the current geolocation permission status
     * @returns the current location authorization state
     */
    static async getPermissionStatus() {
        return new Promise((resolve) => {
            let locationAuthorization = 'NOT_DETERMINED';
            if (!navigator || !navigator.permissions) {
                return resolve(locationAuthorization);
            }
            void navigator.permissions.query({ name: 'geolocation' }).then((permissionsStatus) => {
                switch (permissionsStatus.state) {
                    case 'granted':
                        locationAuthorization = 'GRANTED_FOREGROUND';
                        break;
                    case 'denied':
                        locationAuthorization = 'DENIED';
                        break;
                    case 'prompt':
                        locationAuthorization = 'NOT_DETERMINED';
                        break;
                }
                return resolve(locationAuthorization);
            });
        });
    }
    /** check whether the browser reports being online */
    static online() {
        return navigator && navigator.onLine;
    }
}

var SDK_VERSION = '5.0.0';

const inFlightRequests = new Map();
/** fetch-based HTTP client for Radar API requests */
class Http {
    /**
     * register a custom error factory for network errors matching a host pattern
     * @param hostPattern - substring matched against the request host
     * @param handler - factory that receives online status and returns an error
     */
    static registerErrorInterceptor(hostPattern, handler) {
        Http.errorInterceptors.set(hostPattern, handler);
    }
    static async request({ method, path, data, host, version, headers = {}, responseType, requestId, }) {
        const options = Config.get();
        const publishableKey = options.publishableKey;
        if (!publishableKey) {
            throw new RadarPublishableKeyError('publishableKey not set.');
        }
        const urlHost = host || options.host;
        const urlVersion = version || options.version;
        let url = `${urlHost}/${urlVersion}/${path}`;
        // filter out undefined values from request data
        const filtered = Object.fromEntries(Object.entries(data ?? {}).filter(([, v]) => v !== undefined));
        let body;
        if (method === 'GET') {
            const params = new URLSearchParams(Object.entries(filtered).map(([k, v]) => [k, String(v)]));
            const qs = params.toString();
            if (qs) {
                url = `${url}?${qs}`;
            }
        }
        else {
            body = JSON.stringify(filtered);
        }
        // abort in-flight requests with matching requestIds
        if (requestId) {
            inFlightRequests.get(requestId)?.abort();
        }
        const abortController = new AbortController();
        if (requestId) {
            inFlightRequests.set(requestId, abortController);
        }
        const defaultHeaders = {
            Authorization: publishableKey,
            'Content-Type': 'application/json',
            'X-Radar-Device-Type': 'Web',
            'X-Radar-SDK-Version': SDK_VERSION,
        };
        let configHeaders = {};
        if (typeof options.getRequestHeaders === 'function') {
            configHeaders = options.getRequestHeaders();
        }
        const allHeaders = { ...defaultHeaders, ...configHeaders, ...headers };
        let response;
        try {
            response = await fetch(url, {
                method,
                headers: allHeaders,
                body,
                signal: abortController.signal,
            });
        }
        catch {
            // Delete abort controller instance for this request ID if it hasn't yet been replaced with a different one
            if (requestId && inFlightRequests.get(requestId) === abortController) {
                inFlightRequests.delete(requestId);
            }
            if (host) {
                for (const [pattern, handler] of Http.errorInterceptors) {
                    if (host.includes(pattern)) {
                        throw handler(!!Navigator.online());
                    }
                }
            }
            throw new RadarNetworkError();
        }
        if (requestId && inFlightRequests.get(requestId) === abortController) {
            inFlightRequests.delete(requestId);
        }
        let parsed;
        try {
            if (responseType === 'blob') {
                parsed = { code: response.status, data: await response.blob() };
            }
            else {
                parsed = (await response.json());
            }
        }
        catch (err) {
            if (parsed) {
                throw new RadarServerError(parsed);
            }
            else {
                if (options.debug) {
                    Logger.debug(`API call failed: ${url}`);
                    Logger.debug(String(err));
                }
                throw new RadarUnknownError(parsed);
            }
        }
        if (parsed && typeof parsed === 'object' && 'meta' in parsed) {
            const error = parsed.meta?.error;
            if (error === 'ERROR_PERMISSIONS') {
                throw new RadarPermissionsError('Location permissions not granted.');
            }
            else if (error === 'ERROR_LOCATION') {
                throw new RadarLocationError('Could not determine location.');
            }
            else if (error === 'ERROR_NETWORK') {
                throw new RadarNetworkError();
            }
        }
        if (response.ok) {
            return parsed;
        }
        if (options.debug) {
            Logger.debug(`API call failed: ${url}`);
            Logger.debug(JSON.stringify(parsed));
        }
        if (response.status === 400) {
            throw new RadarBadRequestError(parsed);
        }
        else if (response.status === 401) {
            throw new RadarUnauthorizedError(parsed);
        }
        else if (response.status === 402) {
            throw new RadarPaymentRequiredError(parsed);
        }
        else if (response.status === 403) {
            throw new RadarForbiddenError(parsed);
        }
        else if (response.status === 404) {
            throw new RadarNotFoundError(parsed);
        }
        else if (response.status === 429) {
            throw new RadarRateLimitError(parsed);
        }
        else if (response.status >= 500 && response.status < 600) {
            throw new RadarServerError(parsed);
        }
        else {
            throw new RadarUnknownError(parsed);
        }
    }
}
/** map of host patterns to custom error factories for intercepting network errors */
Http.errorInterceptors = new Map();

/** @internal address validation API — use {@link Radar.validateAddress} instead */
class AddressesAPI {
    /**
     * validate a structured address
     * @param params - address fields to validate
     * @returns validated address and verification result
     */
    static async validateAddress(params) {
        const options = Config.get();
        const response = await Http.request({
            method: 'GET',
            path: 'addresses/validate',
            data: params,
        });
        const { address, result } = response;
        const validateAddressRes = {
            address,
            result,
        };
        if (options.debug) {
            validateAddressRes.response = response;
        }
        return validateAddressRes;
    }
}

const generateUUID = () => {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID();
    }
    // fallback for older browsers
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);
    bytes[6] = (bytes[6] & 0x0f) | 0x40; // version 4
    bytes[8] = (bytes[8] & 0x3f) | 0x80; // variant 10
    const hex = Array.from(bytes, (b) => b.toString(16).padStart(2, '0')).join('');
    return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
};
/** device and install ID manager backed by localStorage */
class Device {
    /**
     * get or generate a persistent device ID
     * @returns the device UUID (persisted in localStorage)
     */
    static getDeviceId() {
        // use existing deviceId if present
        const deviceId = Storage.getItem(Storage.DEVICE_ID);
        if (deviceId) {
            return deviceId;
        }
        // generate new deviceId
        const uuid = generateUUID();
        Storage.setItem(Storage.DEVICE_ID, uuid);
        return uuid;
    }
    /**
     * get or generate a persistent install ID
     * @returns the install UUID (persisted in localStorage)
     */
    static getInstallId() {
        // use existing installId if present
        const deviceId = Storage.getItem(Storage.INSTALL_ID);
        if (deviceId) {
            return deviceId;
        }
        // generate new installId
        const uuid = generateUUID();
        Storage.setItem(Storage.INSTALL_ID, uuid);
        return uuid;
    }
}

const SESSION_TIMEOUT_SECS = 300; // 5 mins
const isValid = (sessionId) => {
    const now = Math.trunc(Date.now() / 1000);
    const session = Number.parseInt(sessionId);
    const diff = Math.abs(now - session);
    return diff < SESSION_TIMEOUT_SECS;
};
/** session ID manager with a 5-minute timeout */
class Session {
    /**
     * get the current session ID, creating a new one if expired
     * @returns unix timestamp string used as session ID
     */
    static getSessionId() {
        const sessionId = Storage.getItem(Storage.SESSION_ID);
        // reuse session if still within 5 min threshold
        if (sessionId && isValid(sessionId)) {
            return sessionId;
        }
        // create new session if does not already exist or expired
        const newSessionId = Math.trunc(Date.now() / 1000).toString(); // unix ts in seconds
        Storage.setItem(Storage.SESSION_ID, newSessionId);
        return newSessionId;
    }
}

/** @internal SDK configuration API for fetching remote config */
class ConfigAPI {
    /**
     * fetch remote SDK configuration from the Radar API. Generic so plugins can extend the response shape.
     *
     * @param params - optional tracking params for device/session identification
     * @param options - optional request overrides (host, headers)
     */
    static async getConfig(params = {}, options = {}) {
        const deviceId = params.deviceId || Device.getDeviceId();
        const installId = params.installId || Device.getInstallId();
        const sessionId = Session.getSessionId();
        // location authorization
        let locationAuthorization;
        try {
            locationAuthorization = await Navigator.getPermissionStatus();
        }
        catch (err) {
            Logger.warn(`Location authorization error: ${err.message}`);
        }
        const data = {
            deviceId,
            installId,
            sessionId,
            locationAuthorization,
        };
        return Http.request({
            method: 'GET',
            path: 'config',
            data,
            host: options.host,
            headers: options.headers,
        });
    }
}

/** @internal context API — use {@link Radar.getContext} instead */
class ContextAPI {
    /**
     * get context (geofences, place, region) for a location
     * @param location - coordinates to get context for
     * @returns geofences, place, country, state, DMA, and postal code
     */
    static async getContext(location) {
        const options = Config.get();
        // get device location if coordinates not provided
        if (!location.latitude || !location.longitude) {
            location = await Navigator.getCurrentPosition();
        }
        const { latitude, longitude, accuracy } = location;
        const response = await Http.request({
            method: 'GET',
            path: 'context',
            data: {
                coordinates: `${latitude},${longitude}`,
                accuracy,
            },
        });
        const { geofences, place, country, state, dma, postalCode } = response;
        const contextRes = {
            location,
            geofences,
            place,
            country,
            state,
            dma,
            postalCode,
        };
        if (options.debug) {
            contextRes.response = response;
        }
        return contextRes;
    }
}

/** @internal conversions API — use {@link Radar.logConversion} instead */
class ConversionsAPI {
    /**
     * log a conversion event
     * @param params - conversion name, user info, and optional metadata/revenue
     * @returns the created event
     */
    static async logConversion(params) {
        const options = Config.get();
        const name = params.name;
        const userId = params.userId || Storage.getItem(Storage.USER_ID);
        const deviceId = params.deviceId || Device.getDeviceId();
        const installId = params.installId || Device.getInstallId();
        const metadata = params.metadata || {};
        const createdAt = params.createdAt;
        if (params.revenue) {
            metadata.revenue = params.revenue;
        }
        const createdAtValue = typeof createdAt === 'string'
            ? createdAt
            : createdAt instanceof Date
                ? createdAt.toISOString()
                : new Date().toISOString();
        const data = {
            name,
            userId,
            deviceId,
            installId,
            metadata,
            createdAt: createdAtValue,
        };
        const response = await Http.request({
            method: 'POST',
            path: 'events',
            data,
        });
        const conversionRes = {
            event: response.event,
        };
        if (options.debug) {
            conversionRes.response = response;
        }
        return conversionRes;
    }
}

/** @internal geocoding API — use Radar.forwardGeocode / reverseGeocode / ipGeocode instead */
class Geocoding {
    /**
     * geocode an address or place name to coordinates
     * @param params - query string, optional layers and country filter
     * @returns matching addresses
     */
    static async forwardGeocode(params) {
        const options = Config.get();
        const { query, layers, country, lang } = params;
        const response = await Http.request({
            method: 'GET',
            path: 'geocode/forward',
            data: {
                query,
                layers,
                country,
                lang,
            },
        });
        const forwardGeocodeRes = {
            addresses: response.addresses,
        };
        if (options.debug) {
            forwardGeocodeRes.response = response;
        }
        return forwardGeocodeRes;
    }
    /**
     * reverse geocode coordinates to addresses
     * @param params - latitude/longitude, optional layers filter
     * @returns matching addresses
     */
    static async reverseGeocode(params) {
        const options = Config.get();
        const { layers } = params;
        let { latitude, longitude } = params;
        if (!latitude || !longitude) {
            const location = await Navigator.getCurrentPosition();
            latitude = location.latitude;
            longitude = location.longitude;
        }
        const response = await Http.request({
            method: 'GET',
            path: 'geocode/reverse',
            data: {
                coordinates: `${latitude},${longitude}`,
                layers,
            },
        });
        const reverseGeocodeRes = {
            addresses: response.addresses,
        };
        if (options.debug) {
            reverseGeocodeRes.response = response;
        }
        return reverseGeocodeRes;
    }
    /**
     * geocode the device's IP address to a rough location
     * @returns IP address, approximate address, and proxy info
     */
    static async ipGeocode() {
        const options = Config.get();
        const response = await Http.request({
            method: 'GET',
            path: 'geocode/ip',
        });
        const ipGeocodeRes = {
            ip: response.ip,
            address: response.address,
            proxy: response.proxy,
        };
        if (options.debug) {
            ipGeocodeRes.response = response;
        }
        return ipGeocodeRes;
    }
}

/** @internal routing API — use Radar.distance / matrix instead */
class RoutingAPI {
    /**
     * calculate travel distance and duration between two points
     * @param params - origin, destination, modes, and units
     * @returns routes with distance and duration per mode
     */
    static async distance(params) {
        const options = Config.get();
        const { units, geometry, geometryPoints } = params;
        let { origin, destination, modes, avoid } = params;
        // use browser location if "near" not provided
        if (!origin) {
            const { latitude, longitude } = await Navigator.getCurrentPosition();
            origin = `${latitude},${longitude}`;
        }
        else if (typeof origin !== 'string') {
            // origin is "Location" object
            const { latitude, longitude } = origin;
            origin = `${latitude},${longitude}`;
        }
        if (typeof destination !== 'string') {
            const { latitude, longitude } = destination;
            destination = `${latitude},${longitude}`;
        }
        if (Array.isArray(modes)) {
            modes = modes.join(',');
        }
        if (Array.isArray(avoid)) {
            avoid = avoid.join(',');
        }
        const response = await Http.request({
            method: 'GET',
            path: 'route/distance',
            data: {
                origin,
                destination,
                modes,
                units,
                geometry,
                geometryPoints,
                avoid,
            },
        });
        const distanceRes = {
            routes: response.routes,
        };
        if (options.debug) {
            distanceRes.response = response;
        }
        return distanceRes;
    }
    /**
     * calculate a distance matrix between multiple origins and destinations
     * @param params - origins, destinations, mode, and units
     * @returns matrix of distances and durations
     */
    static async matrix(params) {
        const options = Config.get();
        const { mode, units } = params;
        let { origins, destinations, avoid } = params;
        // use browser location if "near" not provided
        if (!origins) {
            const { latitude, longitude } = await Navigator.getCurrentPosition();
            const originStrings = [];
            for (let i = 0; i < destinations.length; i++) {
                originStrings.push(`${latitude},${longitude}`);
            }
            origins = originStrings.join('|');
        }
        else if (Array.isArray(origins)) {
            // origin is a list of "Location" objects
            origins = origins.map((location) => `${location.latitude},${location.longitude}`).join('|');
        }
        // convert array to pipe-delimited string
        if (Array.isArray(destinations)) {
            destinations = destinations.map((location) => `${location.latitude},${location.longitude}`).join('|');
        }
        if (Array.isArray(avoid)) {
            avoid = avoid.join(',');
        }
        const response = await Http.request({
            method: 'GET',
            path: 'route/matrix',
            data: {
                origins,
                destinations,
                mode,
                units,
                avoid,
            },
        });
        const matrixRes = {
            origins: response.origins,
            destinations: response.destinations,
            matrix: response.matrix,
        };
        if (options.debug) {
            matrixRes.response = response;
        }
        return matrixRes;
    }
}

/** @internal search API — use Radar.autocomplete / searchGeofences / searchPlaces instead */
class SearchAPI {
    /**
     * autocomplete partial addresses and place names
     * @param params - query and search configuration
     * @param requestId - optional ID for deduplicating in-flight requests
     * @returns matching addresses
     */
    static async autocomplete(params, requestId) {
        const options = Config.get();
        const { query, limit, layers, countryCode, expandUnits, mailable, lang, postalCode } = params;
        let { near } = params;
        // near can be provided as a string or Location object
        // if "near" is not provided, request will fallback to IP based location
        if (near && typeof near !== 'string') {
            if (near.latitude && near.longitude) {
                near = `${near.latitude},${near.longitude}`;
            }
        }
        const response = await Http.request({
            method: 'GET',
            path: 'search/autocomplete',
            data: {
                query,
                near,
                limit,
                layers,
                countryCode,
                expandUnits,
                mailable,
                lang,
                postalCode,
            },
            requestId,
        });
        const autocompleteRes = {
            addresses: response.addresses,
        };
        if (options.debug) {
            autocompleteRes.response = response;
        }
        return autocompleteRes;
    }
    /**
     * search for geofences near a location
     * @param params - location, radius, tags, and filters
     * @returns matching geofences
     */
    static async searchGeofences(params) {
        const options = Config.get();
        const { radius, metadata, limit, includeGeometry } = params;
        let { near, tags } = params;
        // use browser location if "near" not provided
        if (!near) {
            const { latitude, longitude } = await Navigator.getCurrentPosition();
            near = `${latitude},${longitude}`;
        }
        else if (typeof near !== 'string') {
            // near is "Location" object
            const { latitude, longitude } = near;
            near = `${latitude},${longitude}`;
        }
        // convert arrays to comma-strings
        if (Array.isArray(tags)) {
            tags = tags.join(',');
        }
        const response = await Http.request({
            method: 'GET',
            path: 'search/geofences',
            data: {
                near,
                radius,
                tags,
                metadata,
                limit,
                includeGeometry,
            },
        });
        const geofencesSearchRes = {
            geofences: response.geofences,
        };
        if (options.debug) {
            geofencesSearchRes.response = response;
        }
        return geofencesSearchRes;
    }
    /**
     * search for places near a location
     * @param params - location, radius, chains, categories, and groups
     * @returns matching places
     */
    static async searchPlaces(params) {
        const options = Config.get();
        const { radius, limit } = params;
        let { near, chains, categories, groups } = params;
        // use browser location if "near" not provided
        if (!near) {
            const { latitude, longitude } = await Navigator.getCurrentPosition();
            near = `${latitude},${longitude}`;
        }
        else if (typeof near !== 'string') {
            // near is "Location" object
            const { latitude, longitude } = near;
            near = `${latitude},${longitude}`;
        }
        // convert arrays to comma-strings
        if (Array.isArray(chains)) {
            chains = chains.join(',');
        }
        if (Array.isArray(categories)) {
            categories = categories.join(',');
        }
        if (Array.isArray(groups)) {
            groups = groups.join(',');
        }
        const response = await Http.request({
            method: 'GET',
            path: 'search/places',
            data: {
                near,
                radius,
                chains,
                categories,
                groups,
                limit,
            },
        });
        const placeSearchRes = {
            places: response.places,
        };
        if (options.debug) {
            placeSearchRes.response = response;
        }
        return placeSearchRes;
    }
}

// https://stackoverflow.com/a/44198641
const isValidDate = (date) => date && Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date);
/** @internal trips API — use Radar.startTrip / updateTrip / completeTrip / cancelTrip instead */
class TripsAPI {
    /** save trip options to localStorage, pass `undefined` to clear */
    static setTripOptions(tripOptions) {
        if (!tripOptions) {
            TripsAPI.clearTripOptions();
            return;
        }
        const tripOptionsString = JSON.stringify(tripOptions);
        Logger.debug(`Saving trip options: ${tripOptionsString}`);
        Storage.setItem(Storage.TRIP_OPTIONS, tripOptionsString);
    }
    /** get saved trip options from localStorage */
    static getTripOptions() {
        let tripOptions = Storage.getItem(Storage.TRIP_OPTIONS);
        if (tripOptions) {
            tripOptions = JSON.parse(tripOptions);
        }
        return tripOptions;
    }
    /** remove saved trip options from localStorage */
    static clearTripOptions() {
        Storage.removeItem(Storage.TRIP_OPTIONS);
    }
    /**
     * start a new trip
     * @param tripOptions - trip configuration and destination
     * @returns the created trip and any triggered events
     */
    static async startTrip(tripOptions) {
        const options = Config.get();
        tripOptions = tripOptions || TripsAPI.getTripOptions();
        if (!tripOptions) {
            Logger.warn('tripOptions not set when calling "startTrip"');
        }
        const userId = tripOptions.userId || Storage.getItem(Storage.USER_ID);
        if (userId && userId !== Storage.getItem(Storage.USER_ID)) {
            // set as userId for tracking if provided
            Storage.setItem(Storage.USER_ID, userId);
        }
        const { externalId, destinationGeofenceTag, destinationGeofenceExternalId, mode, metadata, approachingThreshold, scheduledArrivalAt, } = tripOptions;
        if (scheduledArrivalAt && !isValidDate(scheduledArrivalAt)) {
            Logger.warn('Invalid date format for scheduledArrivalAt');
        }
        const data = {
            userId,
            externalId,
            destinationGeofenceTag,
            destinationGeofenceExternalId,
            mode,
            metadata,
            approachingThreshold,
            scheduledArrivalAt: isValidDate(scheduledArrivalAt) ? scheduledArrivalAt.toJSON() : undefined,
        };
        const response = await Http.request({
            method: 'POST',
            path: 'trips',
            data,
        });
        // save trip options
        TripsAPI.setTripOptions(tripOptions);
        const tripRes = {
            trip: response.trip,
            events: response.events,
        };
        if (options.debug) {
            tripRes.response = response;
        }
        return tripRes;
    }
    /**
     * update an in-progress trip
     * @param tripOptions - updated trip configuration
     * @param status - optional trip status override
     * @returns the updated trip and any triggered events
     */
    static async updateTrip(tripOptions, status) {
        const options = Config.get();
        tripOptions = tripOptions || TripsAPI.getTripOptions();
        if (!tripOptions) {
            Logger.warn('tripOptions not set when calling "startTrip"');
        }
        const { externalId, destinationGeofenceTag, destinationGeofenceExternalId, mode, metadata, approachingThreshold, scheduledArrivalAt, } = tripOptions;
        if (scheduledArrivalAt && !isValidDate(scheduledArrivalAt)) {
            Logger.warn('Invalid date format for scheduledArrivalAt');
        }
        const data = {
            status,
            externalId,
            destinationGeofenceTag,
            destinationGeofenceExternalId,
            mode,
            metadata,
            approachingThreshold,
            scheduledArrivalAt: isValidDate(scheduledArrivalAt) ? scheduledArrivalAt.toJSON() : undefined,
        };
        const response = await Http.request({
            method: 'PATCH',
            path: `trips/${externalId}/update`,
            data,
        });
        const tripRes = {
            trip: response.trip,
            events: response.events,
        };
        if (options.debug) {
            tripRes.response = response;
        }
        return tripRes;
    }
    /** complete the current trip and clear local trip options */
    static async completeTrip() {
        const tripOptions = TripsAPI.getTripOptions();
        const tripResponse = await TripsAPI.updateTrip(tripOptions, 'completed');
        // clear local trip options
        TripsAPI.clearTripOptions();
        return tripResponse;
    }
    /** cancel the current trip and clear local trip options */
    static async cancelTrip() {
        const tripOptions = TripsAPI.getTripOptions();
        const tripResponse = await TripsAPI.updateTrip(tripOptions, 'canceled');
        // clear local trip options
        TripsAPI.clearTripOptions();
        return tripResponse;
    }
}

/** @internal tracking API — use {@link Radar.trackOnce} instead */
class TrackAPI {
    /**
     * track the user's current location once
     * @param params - tracking parameters (location, user info, trip options)
     * @returns tracked user, events, and location
     */
    static async trackOnce(params) {
        const options = Config.get();
        const { desiredAccuracy } = params;
        let { latitude, longitude, accuracy } = params;
        // if latitude & longitude are not provided,
        // try and retrieve device location (will prompt for location permissions)
        if (!latitude || !longitude) {
            const deviceLocation = await Navigator.getCurrentPosition({ desiredAccuracy });
            latitude = deviceLocation.latitude;
            longitude = deviceLocation.longitude;
            accuracy = deviceLocation.accuracy;
        }
        // location authorization
        const locationAuthorization = await Navigator.getPermissionStatus();
        // user indentification fields
        const userId = params.userId || Storage.getItem(Storage.USER_ID);
        const deviceId = params.deviceId || Device.getDeviceId();
        const installId = params.installId || Device.getInstallId();
        const sessionId = Session.getSessionId();
        const deviceType = params.deviceType || 'Web';
        const description = params.description || Storage.getItem(Storage.DESCRIPTION);
        // save userId for trip tracking
        if (!userId) {
            Logger.warn('userId not provided for trackOnce.');
        }
        else {
            Storage.setItem(Storage.USER_ID, userId);
        }
        // other info
        const metadata = params.metadata || Storage.getJSON(Storage.METADATA);
        // trips
        const tripOptions = params.tripOptions || TripsAPI.getTripOptions();
        if (tripOptions) {
            tripOptions.version = '2';
        }
        const body = {
            ...params,
            locationAuthorization,
            accuracy,
            description,
            deviceId,
            deviceType,
            foreground: true,
            installId,
            sessionId,
            latitude,
            longitude,
            metadata,
            sdkVersion: SDK_VERSION,
            stopped: true,
            userId,
            tripOptions,
        };
        const response = await Http.request({
            method: 'POST',
            path: 'track',
            data: body,
        });
        const { user, events } = response;
        const location = { latitude, longitude, accuracy };
        const trackRes = {
            user,
            events,
            location,
        };
        if (options.debug) {
            trackRes.response = response;
        }
        return trackRes;
    }
}

const isSecretKey = (key) => key.includes('_sk_');
const isLiveKey = (key) => key.includes('_live_');
/**
 * main entry point for the Radar SDK. all methods are static — do not instantiate.
 *
 * @example
 * ```ts
 * Radar.initialize('prj_test_pk_...');
 * const { user, events } = await Radar.trackOnce();
 * ```
 */
class Radar {
    /** current SDK version string */
    static get VERSION() {
        return SDK_VERSION;
    }
    /** register one or more plugins (e.g. maps, autocomplete, fraud) */
    static registerPlugin(...plugins) {
        const ctx = Radar._getPluginContext();
        for (const plugin of plugins) {
            if (Radar._plugins.has(plugin.name)) {
                Logger.warn(`plugin "${plugin.name}" already registered.`);
                continue;
            }
            plugin.install(ctx);
            Radar._plugins.set(plugin.name, plugin);
        }
    }
    static _getPluginContext() {
        return {
            Radar: Radar,
            Config,
            Http,
            Storage,
            Device,
            Session,
            Logger,
            Navigator,
            apis: {
                Addresses: AddressesAPI,
                Config: ConfigAPI,
                Context: ContextAPI,
                Conversions: ConversionsAPI,
                Geocoding: Geocoding,
                Routing: RoutingAPI,
                Search: SearchAPI,
                Track: TrackAPI,
                Trips: TripsAPI,
            },
        };
    }
    /**
     * initialize the SDK with a publishable key. must be called before any other method.
     * @param publishableKey - your Radar publishable key (starts with `prj_test_pk_` or `prj_live_pk_`)
     * @param options - optional SDK configuration
     * @throws {RadarPublishableKeyError} if the key is missing or is a secret key
     */
    static initialize(publishableKey, options = {}) {
        if (!publishableKey) {
            throw new RadarPublishableKeyError('Publishable key required in initialization.');
        }
        if (isSecretKey(publishableKey)) {
            throw new RadarPublishableKeyError('Secret keys are not allowed. Please use your Radar publishable key.');
        }
        // store settings in global config
        const live = isLiveKey(publishableKey);
        const logLevel = live ? 'error' : 'info';
        const debug = !live;
        const radarOptions = Object.assign(Config.defaultOptions, {
            publishableKey,
            live,
            logLevel,
            debug,
        }, options);
        Config.setup(radarOptions);
        Logger.info(`initialized with ${live ? 'live' : 'test'} publishableKey.`);
        if (options.debug) {
            Logger.debug('using options', options);
        }
        // NOTE(jasonl): this allows us to run jest tests
        // without having to mock the ConfigAPI.getConfig call
        if (!window?.RADAR_TEST_ENV) {
            ConfigAPI.getConfig().catch((err) => {
                Logger.warn(`Error calling /config: ${err.message}`);
            });
        }
    }
    /** clear all SDK state and configuration */
    static clear() {
        Config.clear();
    }
    ///////////////////////
    // Geofencing Platform
    ///////////////////////
    /** set the user ID for tracking. pass `undefined` to clear. */
    static setUserId(userId) {
        if (!userId) {
            Storage.removeItem(Storage.USER_ID);
            return;
        }
        Storage.setItem(Storage.USER_ID, String(userId).trim());
    }
    /** set a description for the current user. pass `undefined` to clear. */
    static setDescription(description) {
        if (!description) {
            Storage.removeItem(Storage.DESCRIPTION);
            return;
        }
        Storage.setItem(Storage.DESCRIPTION, String(description).trim());
    }
    /** set custom metadata for the current user. pass `undefined` to clear. */
    static setMetadata(metadata) {
        if (!metadata) {
            Storage.removeItem(Storage.METADATA);
            return;
        }
        Storage.setItem(Storage.METADATA, JSON.stringify(metadata));
    }
    /** get the device's current location using the browser geolocation API */
    static getLocation() {
        return Navigator.getCurrentPosition();
    }
    /** track the user's current location once, returning location context and events */
    static trackOnce(params = {}) {
        try {
            return TrackAPI.trackOnce(params);
        }
        finally {
            // call with updated permissions
            ConfigAPI.getConfig(params).catch((err) => {
                Logger.warn(`Error calling /config: ${err.message}`);
            });
        }
    }
    /** get context (geofences, place, regions) for a location without tracking */
    static getContext(params) {
        return ContextAPI.getContext(params);
    }
    /** save trip options for tracking. pass `undefined` to clear */
    static setTripOptions(tripOptions) {
        TripsAPI.setTripOptions(tripOptions);
    }
    /** clear saved trip options */
    static clearTripOptions() {
        TripsAPI.clearTripOptions();
    }
    /** get the currently saved trip options */
    static getTripOptions() {
        return TripsAPI.getTripOptions();
    }
    /** start a new trip with the given options */
    static startTrip(tripOptions) {
        return TripsAPI.startTrip(tripOptions);
    }
    /** update an in-progress trip */
    static updateTrip(tripOptions) {
        return TripsAPI.updateTrip(tripOptions);
    }
    /** complete the current trip and clear local trip options */
    static completeTrip() {
        return TripsAPI.completeTrip();
    }
    /** cancel the current trip and clear local trip options */
    static cancelTrip() {
        return TripsAPI.cancelTrip();
    }
    /** log a conversion event */
    static logConversion(params) {
        return ConversionsAPI.logConversion(params);
    }
    /** set the product identifier for tracking requests. pass `undefined` to clear */
    static setProduct(product) {
        if (!product) {
            Storage.removeItem(Storage.PRODUCT);
            return;
        }
        Storage.setItem(Storage.PRODUCT, String(product).trim());
    }
    ///////////////////////
    // Listeners
    ///////////////////////
    /** register a global error callback invoked on SDK errors */
    static onError(callback) {
        Config.onError(callback);
    }
    /////////////////
    // Maps Platform
    /////////////////
    /** geocode an address or place name to coordinates */
    static forwardGeocode(params) {
        return Geocoding.forwardGeocode(params);
    }
    /** reverse geocode coordinates to addresses */
    static reverseGeocode(params) {
        return Geocoding.reverseGeocode(params);
    }
    /** geocode the device's IP address to a rough location */
    static ipGeocode() {
        return Geocoding.ipGeocode();
    }
    /** autocomplete partial addresses and place names */
    static autocomplete(params, requestId) {
        return SearchAPI.autocomplete(params, requestId);
    }
    /** search for geofences near a location */
    static searchGeofences(params) {
        return SearchAPI.searchGeofences(params);
    }
    /** search for places (POIs) near a location */
    static searchPlaces(params) {
        return SearchAPI.searchPlaces(params);
    }
    /** validate a structured address */
    static validateAddress(params) {
        return AddressesAPI.validateAddress(params);
    }
    /** calculate travel distance and duration between two points */
    static distance(params) {
        return RoutingAPI.distance(params);
    }
    /** calculate a distance matrix between multiple origins and destinations */
    static matrix(params) {
        return RoutingAPI.matrix(params);
    }
}
Radar._plugins = new Map();
Radar.errors = errors;

export { Radar, Radar as default, errors };
//# sourceMappingURL=radar.js.map
